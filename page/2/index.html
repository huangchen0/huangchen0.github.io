<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="黄尘" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="黄尘的博客">
<meta property="og:url" content="https://huangchen0.github.io/page/2/index.html">
<meta property="og:site_name" content="黄尘的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄尘的博客">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="黄尘的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>黄尘的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">黄尘</a></h1>
        </hgroup>

        
        <p class="header-subtitle">An Android programmer, learn something, share something.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/photo">相册</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/huangcftt@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/huangchen0" title="GitHub"></a>
                            
                                <a class="fa 简书" href="https://www.jianshu.com/u/954800c1eb88" title="简书"></a>
                            
                                <a class="fa 微信" href="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="微信"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Androd进阶/">Androd进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Framework/">Android Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进阶/">Android进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC机制/">GC机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-虚拟机/">Java 虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java并发/">Java并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java进阶/">Java进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义View/">自定义View</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://www.jianshu.com/u/954800c1eb88">简书</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://github.com/huangchen0">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">微信公众号</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">学习不仅仅只是看教程，最好能够想出代码实例去验证自己对某个方面的理解和判断，这样不仅能加深理解，还能够在未来的应用开发中使用到。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">黄尘</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">黄尘</a></h1>
            </hgroup>
            
            <p class="header-subtitle">An Android programmer, learn something, share something.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/photo">相册</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/huangcftt@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/huangchen0" title="GitHub"></a>
                            
                                <a class="fa 简书" target="_blank" href="https://www.jianshu.com/u/954800c1eb88" title="简书"></a>
                            
                                <a class="fa 微信" target="_blank" href="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="微信"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-自定义Gradle-Plugin-插件详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/21/自定义Gradle-Plugin-插件详解/" class="article-date">
      <time datetime="2018-06-21T14:00:40.000Z" itemprop="datePublished">2018-06-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/21/自定义Gradle-Plugin-插件详解/">自定义Gradle-Plugin 插件详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="自定义Gradle-Plugin-插件"><a href="#自定义Gradle-Plugin-插件" class="headerlink" title="自定义Gradle-Plugin 插件"></a>自定义Gradle-Plugin 插件</h2><p><a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="external">官方文档</a>给出了详细的实现步骤，笔者 将参考官方文档：通过自定义插件实现lint文件输出，本文按照以下三个方面进行讲解：</p>
<ul>
<li>插件基础介绍</li>
<li>三种插件的打包方式</li>
<li>实例Demo</li>
</ul>
<h3 id="插件基础介绍"><a href="#插件基础介绍" class="headerlink" title="插件基础介绍"></a>插件基础介绍</h3><blockquote>
<p>官方介绍：A Gradle plugin packages up reusable pieces of build logic, which can be used across many different projects and builds. Gradle allows you to implement your own plugins, so you can reuse your build logic, and share it with others.</p>
<p>You can implement a Gradle plugin in any language you like, provided the implementation ends up compiled as bytecode. In our examples, we are going to use Groovy as the implementation language. Groovy, Java or Kotlin are all good choices as the language to use to implement a plugin, as the Gradle API has been designed to work well with these languages. In general, a plugin implemented using Java or Kotlin, which are statically typed, will perform better than the same plugin implemented using Groovy.</p>
</blockquote>
<p>大体意思：插件打包了可重用的构建逻辑，可以适用不同的项目和构建。</p>
<p>Gradle 提供了很多官方插件，用于支持Java、Groovy等工程的构建和打包。同时也提供了自定义插件机制，让每个人都可以通过插件来实现特定的构建逻辑，并可以把这些逻辑打包起来，分享给其他人。</p>
<p>您可以实现一个Gradle插件用你喜欢任何语言,提供了实现最终编译成字节码。官方例子中,使用Groovy实现语言。Groovy、Java或Kotlin都是不错的选择。深入理解可以参考上一篇文章：<a href="https://www.jianshu.com/p/dbbbe2bf1f7b" target="_blank" rel="external">Android中Gradle深入理解</a></p>
<p>Gradle自定义插件三种方式：</p>
<blockquote>
<p>There are several places where you can put the source for the plugin.</p>
<h4 id="Build-script"><a href="#Build-script" class="headerlink" title="Build script"></a>Build script</h4><p>You can include the source for the plugin directly in the build script. This has the benefit that the plugin is automatically compiled and included in the classpath of the build script without you having to do anything. However, the plugin is not visible outside the build script, and so you cannot reuse the plugin outside the build script it is defined in.</p>
<h4 id="buildSrc-project"><a href="#buildSrc-project" class="headerlink" title="buildSrc project"></a>buildSrc project</h4><p>You can put the source for the plugin in the rootProjectDir/buildSrc/src/main/groovy directory. Gradle will take care of compiling and testing the plugin and making it available on the classpath of the build script. The plugin is visible to every build script used by the build. However, it is not visible outside the build, and so you cannot reuse the plugin outside the build it is defined in.</p>
<p><a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html" target="_blank" rel="external">See Organizing Gradle</a> Projects for more details about the buildSrc project.</p>
<h5 id="Standalone-project"><a href="#Standalone-project" class="headerlink" title="Standalone project"></a>Standalone project</h5><p>You can create a separate project for your plugin. This project produces and publishes a JAR which you can then use in multiple builds and share with others. Generally, this JAR might include some plugins, or bundle several related task classes into a single library. Or some combination of the two.</p>
</blockquote>
<h4 id="大体意思总结为下3点："><a href="#大体意思总结为下3点：" class="headerlink" title="大体意思总结为下3点："></a>大体意思总结为下3点：</h4><blockquote>
<p>1.build.gradle脚本中直接使用。这种方式就是直接在Android Studio app moudle的build.gradle 中进行插件的编写，优点就是不用再上传插件到maven或者其它地方，项目就可以直接使用；缺点也是很明显，就是只能在自己的项目中使用，不能复用，这个不是我们今天要说的。</p>
<p>buildSrc中使用。这种方式需要在项目中新建一个moudle命名为buildSrc，这个目录就用来存放自定义插件。然后在src/main中建立两个目录，一个就是存放代码的groovy目录，一个是存放自定义插件名称的resources目录。这种定义方式也是只能在我们项目中进行使用，不好复用。</p>
<p>3.独立Module中使用。这种方式就是完全独立开发一个Module，可以随便用。</p>
</blockquote>
<p>Build Script</p>
<p>把插件写在build.gradle 文件中，一般用于简单的逻辑，只在改build.gradle 文件中可见，这里直接贴出Demo代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 插件入口类</div><div class="line"> */</div><div class="line">class TestPlugin implements Plugin&lt;Project&gt; &#123;</div><div class="line">    @Override</div><div class="line">    void apply(Project project) &#123;</div><div class="line">        //do something</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: TestPlugin</div></pre></td></tr></table></figure>
<h4 id="buildSrc"><a href="#buildSrc" class="headerlink" title="buildSrc"></a>buildSrc</h4><blockquote>
<h4 id="Use-buildSrc-to-abstract-imperative-logic"><a href="#Use-buildSrc-to-abstract-imperative-logic" class="headerlink" title="Use buildSrc to abstract imperative logic"></a>Use buildSrc to abstract imperative logic</h4><p>Complex build logic is usually a good candidate for being encapsulated either as custom task or binary plugin. Custom task and plugin implementations should not live in the build script. It is very convenient to use buildSrc for that purpose as long as the code does not need to be shared among multiple, independent projects.<br>有兴趣可参考：<a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="external">buildSrc介绍</a></p>
</blockquote>
<p>总得来说：只对该项目中可见，适用于逻辑较为复杂，但又不需要外部可见的插件</p>
<h4 id="独立项目"><a href="#独立项目" class="headerlink" title="独立项目"></a>独立项目</h4><p>先来一个整体代码感受：<br><img src="http://upload-images.jianshu.io/upload_images/1870398-14b60942e81409ca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol>
<li>在Android Studio中新建 Java Library module uploader（moduleName 不重要，根据实际情况定义）</li>
</ol>
<ol>
<li>修改项目文件夹</li>
</ol>
<ul>
<li>[x] 移除java文件夹，因为在这个项目中用不到java代码</li>
<li>[x] 添加Groovy文件夹，主要的代码文件放在这里</li>
<li>[x] 添加resource文件夹，存放用于标识gradle插件的meta-data</li>
</ul>
<ol>
<li>修改build.gradle 文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">apply plugin: &apos;groovy&apos;</div><div class="line"></div><div class="line"></div><div class="line">dependencies&#123;</div><div class="line">    //gradle sdk</div><div class="line">    compile gradleApi()</div><div class="line">    //groovy sdk</div><div class="line">    compile localGroovy()</div><div class="line">&#125;</div><div class="line">//以上配置比较固定</div><div class="line">//以下内容主要用来上传插件</div><div class="line">apply plugin: &apos;maven&apos;</div><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line">group = &apos;com.charles.plugin&apos;</div><div class="line">version = &apos;1.0.0&apos;</div><div class="line"></div><div class="line"></div><div class="line">uploadArchives&#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenDeployer&#123;</div><div class="line">            repository(url: uri(&apos;./../repo&apos;))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建Groovy脚本</li>
</ol>
<p>接下来，在groovy目录下，创建一个Groovy类（与Java类似，可以带包名，但Groovy类以.grovvy结尾，所以groovy文件的创建是new-&gt;file-&gt;custom.groovy）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//插件是一个类 继承Plugin</div><div class="line">class LintPlugin implements Plugin&lt;Project&gt; &#123;</div><div class="line"></div><div class="line">//重载 void apply(Project project)方法，这个方法将会传入使用这个插件的 project 的实例，这是一个重要的 context。</div><div class="line">    @Override</div><div class="line">    void apply(Project project) &#123;</div><div class="line">        /*project.task(&apos;lintOutputsTask&apos;) &#123;</div><div class="line">            doLast &#123;</div><div class="line">                println(&quot;lint outputs task start...&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;*/</div><div class="line">        project.afterEvaluate &#123;</div><div class="line">            project.android.lintOptions.xmlOutput=new File(project.buildDir,&quot;lintResult.xml&quot;)</div><div class="line">        &#125;</div><div class="line">        project.tasks.create(&apos;cleanTest&apos;,CleanTestTask)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建resources<br>resources目录是标识整个插件的目录，也是后面apply plugin的内容。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-0c019686af10f2ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation-class=com.charles.plugin.LintPlugin</div></pre></td></tr></table></figure>
<ol>
<li>在主项目中使用插件<br>在主项目的build.gradle文件中，通过apply指令来加载自定义的插件，脚本如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.charles.plugin&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    ext.kotlin_version = &apos;1.2.30&apos;</div><div class="line">    repositories &#123;</div><div class="line">        google()</div><div class="line">        jcenter()</div><div class="line">        maven &#123;</div><div class="line">            url uri(&apos;./../repo&apos;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:3.1.3&apos;</div><div class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</div><div class="line">        classpath &apos;com.charles.plugin:lintplugin:1.0.0&apos;</div><div class="line"></div><div class="line">        // NOTE: Do not place your application dependencies here; they belong</div><div class="line">        // in the individual module build.gradle files</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比：<br>在buildSrc中创建自定义Gradle插件只能在当前项目中使用，因此，对于具有普遍性的插件来说，通常是建立一个独立的Module来创建自定义Gradle插件。</p>
<p>区别在于：</p>
<ul>
<li>不需要进行model的名称的写死，也就是你可以随意的命名</li>
<li>buildSrc会自动的编译和加入到classpath中，这里我们需要手动依赖</li>
<li>需要上传到maven仓库中</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/dbbbe2bf1f7b" target="_blank" rel="external">Android中Gradle深入理解</a></li>
<li><a href="https://blog.csdn.net/huachao1001/article/details/51810328" target="_blank" rel="external">在AndroidStudio中自定义Gradle插件</a>，</li>
<li><a href="https://blog.csdn.net/eclipsexys/article/details/50973205" target="_blank" rel="external">Gradle自定义插件</a></li>
<li><a href="https://www.jianshu.com/p/66b8eafc2d04" target="_blank" rel="external">一步步自定义Gradle插</a></li>
<li><a href="https://juejin.im/post/5a523dd56fb9a01cbf382ce9" target="_blank" rel="external">自定义Gradle-Plugin 插件</a></li>
<li><a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="external">Gradle官方文档</a></li>
<li><a href="https://www.jianshu.com/p/03eb55536298" target="_blank" rel="external">Gradle自定义插件详解</a></li>
<li>自己Demo代码</li>
</ul>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"> </p>
<p>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gradle/">Gradle</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶–动态代理是基于什么原理？" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/30/Android进阶–动态代理是基于什么原理？/" class="article-date">
      <time datetime="2018-05-30T15:05:24.000Z" itemprop="datePublished">2018-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/30/Android进阶–动态代理是基于什么原理？/">Android进阶–动态代理是基于什么原理？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>最近感悟：对自己负责、对工作负责</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul>
<li>对Java平台的理解？</li>
<li>Java是解释执行，这句话正确吗？</li>
</ul>
</blockquote>
<hr>
<p>首先在这里我们就基于HotSpot虚拟机进行分析（因为作者对HotSpot理解有点模糊，强化一下）</p>
<blockquote>
<p>维基百科：<br>Java HotSpot Virtual Machine<br>开发者    甲骨文公司 (前升阳公司)<br>HotSpot Group<br>HotSpot的正式发布名称为”Java HotSpot Performance Engine”，是<strong>Java虚拟机的一个实</strong>现，包含了<strong>服务器版</strong>和<strong>桌面应用程序版</strong>，现时由Oracle维护并发布。它利用<strong>JIT及自适应优化技术</strong>（自动查找性能热点并进行动态优化，这也是HotSpot名字的由来）来提高性能。</p>
</blockquote>
<h5 id="两种执行方式"><a href="#两种执行方式" class="headerlink" title="两种执行方式"></a>两种执行方式</h5><ul>
<li>解释执行（运行时、解释字节码并执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">强制使用该模式：-Xint</div></pre></td></tr></table></figure>
<ul>
<li>编译执行（将字节码编译为机器码执行，这个编译过程发生在运行期，称为JIT编译）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">强制使用该模式 -Xcomp</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="两种编译模式对比："><a href="#两种编译模式对比：" class="headerlink" title="两种编译模式对比："></a>两种编译模式对比：</h5><ul>
<li>client（即C1）：<strong>只做少量性能开销比高的优化，占用内存少，适用于桌面程序</strong>。</li>
<li>server（即C2）：<strong>进行了大量优化，占用内存多，适用于服务端程序。会收集大量的运行时信息。</strong></li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>解释器：</p>
<ul>
<li>程序启动速度比编译快。</li>
<li>节省内存（不需要编译，所以不需要放置编译后的机器码）。</li>
</ul>
<p>JIT编译器：</p>
<ul>
<li>时间长了，对于“热点代码”的执行会快。</li>
</ul>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意</strong>：</h5><ul>
<li>之所以使用JIT而不是在编译器直接编译成机器码，除了上面解释器的原因以外，还有为了在运行期获取数据，有目的的进行编译。</li>
</ul>
<h4 id="回答问题1："><a href="#回答问题1：" class="headerlink" title="回答问题1："></a>回答问题1：</h4><h5 id="宏观角度："><a href="#宏观角度：" class="headerlink" title="宏观角度："></a>宏观角度：</h5><p>Java平台通过虚拟机屏幕了操作系统的底层细节，使得开发者不需要关心不同操作系统之间的差异。Java平台已经形成了一个生态系统，在这个生态系统中有诸多的研究领域：</p>
<ol>
<li>虚拟机、编译技术的优化（例如：GC优化、JIT、AOT等）：对效率的追求是人类的天性之一。</li>
<li>Java语言本身的变化。</li>
<li>大数据处理。</li>
<li>客户端开发（例如：Android平台）</li>
<li>…</li>
</ol>
<h5 id="微观角度："><a href="#微观角度：" class="headerlink" title="微观角度："></a>微观角度：</h5><ol>
<li>Java语言本身、JDK中所提供的核心类库和相关工具：<ul>
<li>面向对象（封装、继承、多态）</li>
<li>跨平台（JVM运行.class文件）</li>
<li>语言（泛型、Lambda)</li>
<li>类库（集合、并发、网络、IO/NIO)</li>
<li>JRE（Java运行环境、JVM、类库）</li>
<li>JDK (JDK开发工具、包括JRE、javac、诊断工具)</li>
<li>…</li>
</ul>
</li>
<li>Java虚拟机以及其他包含的GC。</li>
</ol>
<h4 id="回答问题2："><a href="#回答问题2：" class="headerlink" title="回答问题2："></a>回答问题2：</h4><p>回答片面，不正确！</p>
<ul>
<li>Java源文件经过javac编译成字节码文件（.class文件）</li>
<li><p>.class文件经过JVM解释执行或者编译执行</p>
<ul>
<li>解析：.class文件经过JVM内嵌的解析器解析执行。</li>
<li>编译：存在JIT编译器（Just In Time Compile 即使编译器）把经常运行的代码作为“热点代码”编译成本地相关的机器代码，并且做各种层次的优化。</li>
<li>AOT编译器：Java9提供的直接将所有的代码编译成机器码执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面答案分析相信也会随着知识面的不断拓宽而不断的进行优化修改</p>
</blockquote>
<p>参考：<a href="https://www.cnblogs.com/java-zhao/p/5203144.html" target="_blank" rel="external">https://www.cnblogs.com/java-zhao/p/5203144.html</a><br>，极客时间APP第1讲|谈谈你对Java平台的理解</p>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"><br>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android进阶/">Android进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android–进阶对Java平台的理解？Java是解释执行吗？" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/21/Android–进阶对Java平台的理解？Java是解释执行吗？/" class="article-date">
      <time datetime="2018-05-21T07:06:57.000Z" itemprop="datePublished">2018-05-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/21/Android–进阶对Java平台的理解？Java是解释执行吗？/">Android–进阶对Java平台的理解？Java是解释执行吗？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>最近感悟：对自己负责、对工作负责</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul>
<li>对Java平台的理解？</li>
<li>Java是解释执行，这句话正确吗？</li>
</ul>
</blockquote>
<hr>
<p>首先在这里我们就基于HotSpot虚拟机进行分析（因为作者对HotSpot理解有点模糊，强化一下）</p>
<blockquote>
<p>维基百科：<br>Java HotSpot Virtual Machine<br>开发者    甲骨文公司 (前升阳公司)<br>HotSpot Group<br>HotSpot的正式发布名称为”Java HotSpot Performance Engine”，是<strong>Java虚拟机的一个实</strong>现，包含了<strong>服务器版</strong>和<strong>桌面应用程序版</strong>，现时由Oracle维护并发布。它利用<strong>JIT及自适应优化技术</strong>（自动查找性能热点并进行动态优化，这也是HotSpot名字的由来）来提高性能。</p>
</blockquote>
<h5 id="两种执行方式"><a href="#两种执行方式" class="headerlink" title="两种执行方式"></a>两种执行方式</h5><ul>
<li>解释执行（运行时、解释字节码并执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">强制使用该模式：-Xint</div></pre></td></tr></table></figure>
<ul>
<li>编译执行（将字节码编译为机器码执行，这个编译过程发生在运行期，称为JIT编译）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">强制使用该模式 -Xcomp</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="两种编译模式对比："><a href="#两种编译模式对比：" class="headerlink" title="两种编译模式对比："></a>两种编译模式对比：</h5><ul>
<li>client（即C1）：<strong>只做少量性能开销比高的优化，占用内存少，适用于桌面程序</strong>。</li>
<li>server（即C2）：<strong>进行了大量优化，占用内存多，适用于服务端程序。会收集大量的运行时信息。</strong></li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>解释器：</p>
<ul>
<li>程序启动速度比编译快。</li>
<li>节省内存（不需要编译，所以不需要放置编译后的机器码）。</li>
</ul>
<p>JIT编译器：</p>
<ul>
<li>时间长了，对于“热点代码”的执行会快。</li>
</ul>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意</strong>：</h5><ul>
<li>之所以使用JIT而不是在编译器直接编译成机器码，除了上面解释器的原因以外，还有为了在运行期获取数据，有目的的进行编译。</li>
</ul>
<h4 id="回答问题1："><a href="#回答问题1：" class="headerlink" title="回答问题1："></a>回答问题1：</h4><h5 id="宏观角度："><a href="#宏观角度：" class="headerlink" title="宏观角度："></a>宏观角度：</h5><p>Java平台通过虚拟机屏幕了操作系统的底层细节，使得开发者不需要关心不同操作系统之间的差异。Java平台已经形成了一个生态系统，在这个生态系统中有诸多的研究领域：</p>
<ol>
<li>虚拟机、编译技术的优化（例如：GC优化、JIT、AOT等）：对效率的追求是人类的天性之一。</li>
<li>Java语言本身的变化。</li>
<li>大数据处理。</li>
<li>客户端开发（例如：Android平台）</li>
<li>…</li>
</ol>
<h5 id="微观角度："><a href="#微观角度：" class="headerlink" title="微观角度："></a>微观角度：</h5><ol>
<li>Java语言本身、JDK中所提供的核心类库和相关工具：<ul>
<li>面向对象（封装、继承、多态）</li>
<li>跨平台（JVM运行.class文件）</li>
<li>语言（泛型、Lambda)</li>
<li>类库（集合、并发、网络、IO/NIO)</li>
<li>JRE（Java运行环境、JVM、类库）</li>
<li>JDK (JDK开发工具、包括JRE、javac、诊断工具)</li>
<li>…</li>
</ul>
</li>
<li>Java虚拟机以及其他包含的GC。</li>
</ol>
<h4 id="回答问题2："><a href="#回答问题2：" class="headerlink" title="回答问题2："></a>回答问题2：</h4><p>回答片面，不正确！</p>
<ul>
<li>Java源文件经过javac编译成字节码文件（.class文件）</li>
<li><p>.class文件经过JVM解释执行或者编译执行</p>
<ul>
<li>解析：.class文件经过JVM内嵌的解析器解析执行。</li>
<li>编译：存在JIT编译器（Just In Time Compile 即使编译器）把经常运行的代码作为“热点代码”编译成本地相关的机器代码，并且做各种层次的优化。</li>
<li>AOT编译器：Java9提供的直接将所有的代码编译成机器码执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面答案分析相信也会随着知识面的不断拓宽而不断的进行优化修改</p>
</blockquote>
<p>参考：<a href="https://www.cnblogs.com/java-zhao/p/5203144.html" target="_blank" rel="external">https://www.cnblogs.com/java-zhao/p/5203144.html</a><br>，极客时间APP第1讲|谈谈你对Java平台的理解</p>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"><br>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶–Exception和Error的理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/10/Android进阶–Exception和Error的理解/" class="article-date">
      <time datetime="2018-05-10T14:06:42.000Z" itemprop="datePublished">2018-05-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/Android进阶–Exception和Error的理解/">Android进阶–Exception和Error的理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>今日感悟：越是厉害的人，代码越容易理解</p>
</blockquote>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>请对比Exception和Error的区别，另外，运行时异常和一般异常有什么区别？</li>
</ul>
<h4 id="知识点分析："><a href="#知识点分析：" class="headerlink" title="知识点分析："></a>知识点分析：</h4><p>一. 首先来个简单的类图感受一下Throwable、Exception、Error的设计和分类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-83c9bc9b57f2eb0a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>从上图中可以看出Exception和Error都是继承Throwable，也就是中Java中只有Throwable类型的实例才可以被抛出（Throw)或者捕获（catch)。</p>
<p>二. 掌握最基本的语法。如try-catch-finally块、throw、throws关键字等。同时懂得如何处理典型场景。</p>
<h6 id="知识点补充："><a href="#知识点补充：" class="headerlink" title="知识点补充："></a>知识点补充：</h6><p>随着Java语言的扩展，引入了一些更加便利的特性，try-with-resources和multiple catch。具体我这里引用了RxJava和Retorfit结合源码的一段。在编译时期，会自动生成相应的处理逻辑，比如：自定义AutoCloseable实现（AutoCloseable不了解的可以参考文章<a href="http://ifeve.com/java-7%E4%B8%AD%E7%9A%84try-with-resources/" target="_blank" rel="external">Java7中的Try-with-resources</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//代码路径：</div><div class="line">package retrofit2.adapter.rxjava2.CallExecuteObservable</div><div class="line"></div><div class="line">@Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</div><div class="line">   //省略逻辑</div><div class="line">   ...</div><div class="line">   </div><div class="line">    try &#123;</div><div class="line">    //划重点了，这里没有贴代码，感兴趣自己调式execute方法 </div><div class="line">      Response&lt;T&gt; response = call.execute();</div><div class="line">      if (!disposable.isDisposed()) &#123;</div><div class="line">        observer.onNext(response);</div><div class="line">      &#125;</div><div class="line">      if (!disposable.isDisposed()) &#123;</div><div class="line">        terminated = true;</div><div class="line">        observer.onComplete();</div><div class="line">      &#125;</div><div class="line">    &#125; catch (Throwable t) &#123;</div><div class="line">    //划重点了，跟随优秀的开源框架一步步进去，你会发现它遵循了：</div><div class="line">    //1.尽量捕获具体异常,不要捕获Throable或者Error //2.不生吞（swallow)异常</div><div class="line">    //3.throw early</div><div class="line">    //4.仅仅捕获必要代码块，try-catch会产生额外的性能开销</div><div class="line">      Exceptions.throwIfFatal(t);</div><div class="line">      if (terminated) &#123;</div><div class="line">        RxJavaPlugins.onError(t);</div><div class="line">      &#125; else if (!disposable.isDisposed()) &#123;</div><div class="line">        try &#123;</div><div class="line">          observer.onError(t);</div><div class="line">        &#125; catch (Throwable inner) &#123;</div><div class="line">          Exceptions.throwIfFatal(inner);</div><div class="line">          RxJavaPlugins.onError(new CompositeException(t, inner));</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="回答问题："><a href="#回答问题：" class="headerlink" title="回答问题："></a>回答问题：</h4><p>这边就不写了，根据上面类图和文字补充，各自组织语言吧（重要的是自己要有深度思考能力）</p>
<p>参考：<a href="http://ifeve.com/java-7%E4%B8%AD%E7%9A%84try-with-resources/" target="_blank" rel="external">http://ifeve.com/java-7%E4%B8%AD%E7%9A%84try-with-resources/</a> ，极客时间APP核心技术第二讲|Exception和Error有什么区别、retrofit2.adapter.rxjava2部分源码</p>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"><br>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶–String、StringBuffer、StringBuilder的理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/06/Android进阶–String、StringBuffer、StringBuilder的理解/" class="article-date">
      <time datetime="2018-05-06T14:05:40.000Z" itemprop="datePublished">2018-05-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/06/Android进阶–String、StringBuffer、StringBuilder的理解/">Android进阶–String、StringBuffer、StringBuilder的理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><p>理解 Java的字符串，String、StringBuffer、StringBuilder 有什么区别？</p>
<h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ol>
<li>字符串设计和实现考量<br>String是Immutable(线程安全、字符串常量池复用)。<strong>Immutable对象在拷贝时候不需要额外复制数据</strong>。至于为什么imumutable，源码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//关键点 final </div><div class="line">public final class String</div><div class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</div><div class="line"></div><div class="line">    // The associated character storage is managed by the runtime. We only</div><div class="line">    // keep track of the length here.</div><div class="line">    //关键点final private</div><div class="line">    // private final char value[];</div><div class="line">    private final int count;</div></pre></td></tr></table></figure>
<ol>
<li>StringBuffer、StringBuilder底层都是利用可修改的数组（JDK 9之后是byte)数组，都继承了AbstractStringBuilder，里面包含了基本操作。区别StringBuffer增加了synchronized。相关源码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//AbstractStringBuilder 没有加final 也没private修饰</div><div class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</div><div class="line">    char[] value;</div><div class="line">    int count;</div><div class="line">    private static final int MAX_ARRAY_SIZE = 2147483639;</div><div class="line"></div><div class="line">    AbstractStringBuilder() &#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//StringBuilder截取部分源码</div><div class="line">static final long serialVersionUID = 4383685877147921099L;</div><div class="line"></div><div class="line">    public StringBuilder() &#123;</div><div class="line">        super(16);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public StringBuilder(int var1) &#123;</div><div class="line">        super(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public StringBuilder(String var1) &#123;</div><div class="line">        super(var1.length() + 16);</div><div class="line">        this.append(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public StringBuilder(CharSequence var1) &#123;</div><div class="line">        this(var1.length() + 16);</div><div class="line">        this.append(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public StringBuilder append(Object var1) &#123;</div><div class="line">        return this.append(String.valueOf(var1));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public StringBuilder append(String var1) &#123;</div><div class="line">        super.append(var1);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public StringBuilder append(StringBuffer var1) &#123;</div><div class="line">        super.append(var1);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public StringBuilder append(CharSequence var1) &#123;</div><div class="line">        super.append(var1);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public StringBuilder append(CharSequence var1, int var2, int var3) &#123;</div><div class="line">        super.append(var1, var2, var3);</div><div class="line">        return this;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//StringBuffer部分源码 多了synchronized</div><div class="line">public StringBuffer(CharSequence seq) &#123;</div><div class="line">        this(seq.length() + 16);</div><div class="line">        append(seq);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized int length() &#123;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized int capacity() &#123;</div><div class="line">        return value.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public synchronized void ensureCapacity(int minimumCapacity) &#123;</div><div class="line">        if (minimumCapacity &gt; value.length) &#123;</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>字符串缓存<br>String在Java 6 以后提供了intern（）方法，目的是提示JVM把相应字符串缓存起来，以便重复使用。<blockquote>
<p>注意：Java 6这种历史版本，并不推荐大量使用intern()，因为缓存的字符串是存在“永久代”中，这个空间比较有限。也基本不会被FULLGC之外的垃圾收集照顾到。所以，使用不当，容易OOM。后续版本中，被放到堆中，设置永久代在Java 8中被元数据区替代了。</p>
</blockquote>
</li>
</ol>
<p>intern()感兴趣可以参考文章：<a href="https://www.cnblogs.com/Qian123/p/5707154.html" target="_blank" rel="external">Java提高篇——理解String 及 String.intern() 在实际中的应用</a></p>
<ol>
<li>String自身也有相关优化<br>有兴趣可以自己查看相关文章，主要是char数组换成了byte数组加上一个标志编码所谓的coder。</li>
</ol>
<h5 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题:"></a>回答问题:</h5><h6 id="String的创建机理"><a href="#String的创建机理" class="headerlink" title="String的创建机理"></a>String的创建机理</h6><p>由于String在Java世界中使用过于频繁，Java为了避免在一个系统中使用大量的Java对象，引入了字符串常量池的概念。其<strong>运行机制是:创建一个字符串的时候，首先检查池中是否有相等的字符串对象，如果有就不需要创建，直接从池中找到对象引用，如果没有的话，新建字符串对象，返回对象引用</strong>。但是，通过new方法创建的不会检查常量池是否存在，而是直接在堆中或者栈中创建一个新的对象，也不会把对象放入池中。上面所说的只适用于直接给String引用赋值的情况。</p>
<blockquote>
<p>注意：String是immutable<br>Strng提供了inter()方法可以将Strng对象添加到池中，并且返回该对象的引用。(如果由equals()确定池中有该字符串，那就直接返回)。</p>
</blockquote>
<p>当两个String对象拥有相等的值的时候，他们只引用字符串中同一个拷贝。当同一个字符串大量出现的时候，可以大量节省内存空间。</p>
<h5 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer/StringBuilder"></a>StringBuffer/StringBuilder</h5><p>StringBuffer/StringBuilder相同点：</p>
<ul>
<li>String/StringBuilder相对于String的话，他们值是可以改变的，并且值改变后，他们引用不会变。他们在构造的时候使用一个默认的数组，在后续加入数据后超过默认大小后会创建更大的数组，并且将原来数组的内容复制过来，再丢弃旧的数组。因此，项目开发的时候，对于较大对象的扩容会性能，因此，能预估大小，最好不过。</li>
</ul>
<p>StringBuffer/StringBuilder不同点：</p>
<ul>
<li>另外StringBuffer是线程安全(方法定义前面使用了synchronize)，StringBuilder不是。StringBuffer性能要低于StringBuilder。<h5 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h5>String 适用于常量声明。如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int DEVICE_NOT_AVAILABLE_ERROR_CODE = 390004;// 设备未启用或者被锁住</div></pre></td></tr></table></figure>
<p>StringBuffer，适用于频繁进行字符串运算(如拼接、替换、删除等)，并且运行在多线程环境下，建议使用，比如Http参数解析和封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 获取POST请求的base url</div><div class="line">     *</div><div class="line">     * @param requestHolder</div><div class="line">     * @return</div><div class="line">     * @throws AlipayApiException</div><div class="line">     */</div><div class="line">    private String getRequestUrl(RequestParametersHolder requestHolder) throws AlipayApiException &#123;</div><div class="line">        StringBuffer urlSb = new StringBuffer(serverUrl);</div><div class="line">        try &#123;</div><div class="line">            String sysMustQuery = WebUtils.buildQuery(requestHolder.getProtocalMustParams(),</div><div class="line">                    charset);</div><div class="line">            String sysOptQuery = WebUtils.buildQuery(requestHolder.getProtocalOptParams(), charset);</div><div class="line"></div><div class="line">            urlSb.append(&quot;?&quot;);</div><div class="line">            urlSb.append(sysMustQuery);</div><div class="line">            if (sysOptQuery != null &amp; sysOptQuery.length() &gt; 0) &#123;</div><div class="line">                urlSb.append(&quot;&amp;&quot;);</div><div class="line">                urlSb.append(sysOptQuery);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            throw new AlipayApiException(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return urlSb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>StringBuilder，适用于频繁进行字符串运算(如拼接、替换、删除等)，并且运行在单线程环境下，建议使用，比如Json的封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">         * Extracts absolute path form a given URI. E.g., passing</div><div class="line">         * &lt;code&gt;http://google.com:80/execute?query=cat#top&lt;/code&gt;</div><div class="line">         * will result in &lt;code&gt;/execute?query=cat#top&lt;/code&gt;.</div><div class="line">         *</div><div class="line">         * @param uri URI which absolute path has to be extracted,</div><div class="line">         * @return the absolute path of the URI,</div><div class="line">         */</div><div class="line">        private String getAbsolutePathFromAbsoluteURI(URI uri) &#123;</div><div class="line">            String rawPath = uri.getRawPath();</div><div class="line">            String rawQuery = uri.getRawQuery();</div><div class="line">            String rawFragment = uri.getRawFragment();</div><div class="line">            StringBuilder absolutePath = new StringBuilder();</div><div class="line"></div><div class="line">            if (rawPath != null) &#123;</div><div class="line">                absolutePath.append(rawPath);</div><div class="line">            &#125; else &#123;</div><div class="line">                absolutePath.append(&quot;/&quot;);</div><div class="line">            &#125;</div><div class="line">            if (rawQuery != null) &#123;</div><div class="line">                absolutePath.append(&quot;?&quot;).append(rawQuery);</div><div class="line">            &#125;</div><div class="line">            if (rawFragment != null) &#123;</div><div class="line">                absolutePath.append(&quot;#&quot;).append(rawFragment);</div><div class="line">            &#125;</div><div class="line">            return absolutePath.toString();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/Qian123/p/5707154.html" target="_blank" rel="external">Java提高篇——理解String 及 String.intern() 在实际中的应用</a></li>
<li>String、StringBuffer、StringBuilder部分源码</li>
<li>自己开发Demo中部分代码</li>
<li>极客时间APP核心技术第五讲|String、StringBuffer、StringBuilder有什么区别？</li>
</ul>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"><br>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶–final、finally、finalize的理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/23/Android进阶–final、finally、finalize的理解/" class="article-date">
      <time datetime="2018-04-23T14:06:28.000Z" itemprop="datePublished">2018-04-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/23/Android进阶–final、finally、finalize的理解/">Android进阶–final、finally、finalize的理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>首先补充听课心得（二）内容：默认情况在Android Studio中使用try-with-resources会提示Try-with-resources requires API level 19的警告️ ，你需要自己再build.gradle文件中设置指定JDK版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">compileOptions &#123;</div><div class="line">    sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">    targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul>
<li>final、finally、finalize有什么区别？</li>
</ul>
<p>这是一道经典的基础面试题，这里不作分析，不了解的自己Google哦（它们除了字母类似，各自之间没啥关系，有点类似Java和JavaScript有啥关系了）</p>
<h5 id="补充其他知识点："><a href="#补充其他知识点：" class="headerlink" title="补充其他知识点："></a>补充其他知识点：</h5><ol>
<li>final也许会有性能的好处，比如利用final可能（注意是可能）对性能有好处。比如：可能有助于将方法进行内联，可以改善编译器进行条件编译的能力等等。日常开发中，除非有特别考虑，不然最好不要指望这种小技巧带来所谓的性能提升。</li>
<li>不要在finally中使用return语句，finally总是执行，除非程序或者线程被终止。比如以下代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//try-catch异常退出、不被执行</div><div class="line">try&#123;</div><div class="line">    system.exit(1)</div><div class="line">&#125;finally&#123;</div><div class="line">    println(&quot;会被执行吗？&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//try-catch无线循环，不被执行</div><div class="line">try&#123;</div><div class="line">    while(true)&#123;</div><div class="line">        println(&quot;do something&quot;)</div><div class="line">    &#125;finally&#123;</div><div class="line">        println(&quot;会被执行吗？&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你非要在finally中使用return语句，请注意以下结论：</p>
<ul>
<li>finally块的语句是在try|catch的return语句执行之后，返回之前（try|catch中return在返回前，将其他所有操作都执行完，保留返回的值）。</li>
<li>finally中return语句会覆盖try|catch中return语句直接返回。</li>
</ul>
<p>具体代码实践请参考文章<a href="http://www.cnblogs.com/lanxuezaipiao/p/3440471.html" target="_blank" rel="external">：Java finally语句到底是在return之前还是之后执行？</a><br><a href="https://itimetraveler.github.io/2017/09/20/%E3%80%90Java%E3%80%91try-catch-finally%E8%AF%AD%E5%8F%A5%E4%B8%ADreturn%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%9D%E8%80%83/" target="_blank" rel="external">try-catch-finally语句中return的执行顺序思考</a></p>
<ol>
<li>final不是immutable。（类似：String为什么需要final修饰？HashMap、HashSet的键值为什么不要使用不可变类型？）除了immutable内部如何实现的,个人认为主要作用：</li>
</ol>
<ul>
<li>安全，尤其并发的时候线程安全</li>
<li>类似String设计成immutable有着一个字符串常量池的属性，这样存在大量字符串的时候，节省内存空间、提高效率。具体类似讨论可以参考知乎文章<a href="https://www.zhihu.com/question/31345592" target="_blank" rel="external">：在java中String类为什么要设计成final？</a></li>
</ul>
<ol>
<li>小插曲，对Java的finalizer，cleaner的理解。有兴趣可以参考文章<a href="https://www.zhihu.com/question/62953438" target="_blank" rel="external">：Java的finalizer，cleaner等如何实现？</a>   <a href="https://www.cnblogs.com/IcanFixIt/p/8133798.html" target="_blank" rel="external">Effective Java 第三版——8. 避免使用Finalizer和Cleaner机制</a></li>
</ol>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/lanxuezaipiao/p/3440471.html" target="_blank" rel="external">Java finally语句到底是在return之前还是之后执行？</a></li>
<li><a href="https://itimetraveler.github.io/2017/09/20/%E3%80%90Java%E3%80%91try-catch-finally%E8%AF%AD%E5%8F%A5%E4%B8%ADreturn%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%9D%E8%80%83/" target="_blank" rel="external">try-catch-finally语句中return的执行顺序思考</a></li>
<li><a href="https://www.zhihu.com/question/62953438" target="_blank" rel="external">Java的finalizer，cleaner等如何实现？</a> </li>
<li><a href="https://www.cnblogs.com/IcanFixIt/p/8133798.html" target="_blank" rel="external">Effective Java 第三版——8. 避免使用Finalizer和Cleaner机制</a></li>
<li>极客时间APP核心技术第三讲|谈谈final、finally、finalize有什么区别？</li>
</ul>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"><br>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Kotlin单例模式多种写法大分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/21/Kotlin单例模式多种写法大分析/" class="article-date">
      <time datetime="2018-04-21T15:58:53.000Z" itemprop="datePublished">2018-04-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/21/Kotlin单例模式多种写法大分析/">Kotlin单例模式多种写法大分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>今天，在项目开发中，又运用到了单例模式另外一种Kotlin写法，于是决定记录下来，以供参考。</p>
<h5 id="几种单例模式："><a href="#几种单例模式：" class="headerlink" title="几种单例模式："></a>几种单例模式：</h5><ul>
<li>饿汉式</li>
<li>双重校验懒汉式</li>
<li>静态内部类式</li>
</ul>
<h3 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 作者：huangchen on 2018/8/7 21:48</div><div class="line"> * 邮箱：huangcftt@gmail.com</div><div class="line"> */</div><div class="line">//java实现</div><div class="line">public class PayManager &#123;</div><div class="line">    private static PayManager payManager = new PayManager();</div><div class="line"></div><div class="line">    public static PayManager getPayManager() &#123;</div><div class="line">        return payManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private PayManager()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 作者：huangchen on 2018/8/7 21:55</div><div class="line"> * 邮箱：huangcftt@gmail.com</div><div class="line"> */</div><div class="line">//Kotlin实现</div><div class="line">object PayServiceManager</div></pre></td></tr></table></figure>
<p>是不是大吃一惊。我靠一个object 关键字就完成相同的功能？一行代码？</p>
<p><a href="https://www.kotlincn.net/docs/reference/object-declarations.html#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">Kotlin的对象声明</a>学习了Kotlin的小伙伴肯定知道,在Kotlin中类没有静态方法。如果你需要写一个可以无需用一个类的实例来调用，但需要访问类内部的函数（例如，工厂方法,单例等），你可以把该类声明为一个对象。该对象与其他语言的静态成员是类似的。</p>
<blockquote>
<p>对象声明的初始化过程是线程安全的。</p>
</blockquote>
<p>查看kotlin Bytecode 后 Decompile后：</p>
<figure class="highlight plain"><figcaption><span>kotlin.Metadata;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Metadata(</div><div class="line">   mv = &#123;1, 1, 9&#125;,</div><div class="line">   bv = &#123;1, 0, 2&#125;,</div><div class="line">   k = 1,</div><div class="line">   d1 = &#123;&quot;\u0000\f\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\bÆ\u0002\u0018\u00002\u00020\u0001B\u0007\b\u0002¢\u0006\u0002\u0010\u0002¨\u0006\u0003&quot;&#125;,</div><div class="line">   d2 = &#123;&quot;Lcn/yonghui/shop/shopapplication/pay/config/PayServiceManager;&quot;, &quot;&quot;, &quot;()V&quot;, &quot;production sources for module app&quot;&#125;</div><div class="line">)</div><div class="line">public final class PayServiceManager &#123;</div><div class="line">   public static final PayServiceManager INSTANCE;</div><div class="line"></div><div class="line">   static &#123;</div><div class="line">      PayServiceManager var0 = new PayServiceManager();</div><div class="line">      INSTANCE = var0;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上代码，我们了解事实就是这个样子的，使用Kotlin”object”进行对象声明与我们的饿汉式单例的代码基本是相同的。</p>
<h3 id="2-双重校验懒汉式"><a href="#2-双重校验懒汉式" class="headerlink" title="2. 双重校验懒汉式"></a>2. 双重校验懒汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//java 代码</div><div class="line"> private PayManager()&#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private  volatile static PayManager payManager;</div><div class="line"></div><div class="line">    public static  PayManager getPayManager() &#123;</div><div class="line">        if(payManager == null)&#123;</div><div class="line">            synchronized (PayManager.class)&#123;</div><div class="line">                if(payManager == null)&#123;</div><div class="line">                    payManager = new PayManager()</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return payManager;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//kotlin实现</div><div class="line">class PayServiceManager private constructor() &#123;</div><div class="line">    companion object &#123;</div><div class="line">        val instance: PayServiceManager by lazy &#123;</div><div class="line">            PayServiceManager()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>显式声明构造方法为private</li>
<li>companion object用来在class内部声明一个对象</li>
<li>PayServiceManager的实例instance 通过lazy来实现懒汉式加载</li>
<li>lazy默认情况下是线程安全的，这就可以避免多个线程同时访问生成多个实例的问题<h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4></li>
<li>lazy()是接受一个 lambda 并返回一个 Lazy <t> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</t></li>
<li>默认情况下，对于 lazy 属性的求值是同步锁的（synchronized）：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。 而如果你确定初始化将总是发生在单个线程，那么你可以使用 LazyThreadSafetyMode.NONE 模式， 它不会有任何线程安全的保证以及相关的开销。<br>有兴趣可参考：<a href="https://www.kotlincn.net/docs/reference/delegated-properties.html" target="_blank" rel="external">lazy讲解</a></li>
</ul>
<h3 id="3-静态内部类式"><a href="#3-静态内部类式" class="headerlink" title="3. 静态内部类式"></a>3. 静态内部类式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//Java实现</div><div class="line">private PayManager()&#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   private static class PayManagerHolder&#123;</div><div class="line">       private static PayManager payManager = new PayManager();</div><div class="line">   &#125;</div><div class="line">   public static PayManager getPayManager()&#123;</div><div class="line">       return PayManagerHolder.payManager;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//kotlin实现</div><div class="line">class PayServiceManager private constructor() &#123;</div><div class="line">    companion object &#123;</div><div class="line">        val instance =PayServiceManagerHolder.payServiceManager</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private object PayServiceManagerHolder &#123;</div><div class="line">        val payServiceManager = PayServiceManager()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态内部类java代码和Kotlin代码基本类似。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>对于资源占用和实例初始化时间比较少的时候，应该使用object形式的饿汉式加载。否则的话使用懒汉式。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.kotlincn.net/docs/reference/classes.html" target="_blank" rel="external">Kotlin参考文档</a></li>
<li><a href="https://juejin.im/post/5acf49a06fb9a028d700ff4d" target="_blank" rel="external">Kotlin下的5种单例模式</a>，</li>
<li><a href="https://droidyue.com/blog/2017/07/17/singleton-in-kotlin/" target="_blank" rel="external">Kotlin中的单例模式</a></li>
<li>自己Demo代码</li>
</ul>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"> </p>
<p>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-synchronized和ReentrantLock的理解（上）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/30/synchronized和ReentrantLock的理解（上）/" class="article-date">
      <time datetime="2018-03-30T14:01:17.000Z" itemprop="datePublished">2018-03-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/30/synchronized和ReentrantLock的理解（上）/">synchronized和ReentrantLock的理解（上）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>synchronized和ReentrantLock有什么全部？</li>
<li>有人说synchronized最慢，这话靠谱吗？<h3 id="回答问题："><a href="#回答问题：" class="headerlink" title="回答问题："></a>回答问题：</h3>synchronized是Java内建的同步机制，所以也有人称其为Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他获取的线程只能等待或者阻塞在那里。</li>
</ul>
<blockquote>
<p>注意：原子性意味着一个线程一次只能执行由一个指定监控对象（lock）保护的代码，从而防止多个线程在更新共享状态时相互冲突。可见性则更为微妙；它要对付内存缓存和编译器优化的各种反常行为。一般来说，线程以某种不必让其他线程立即可以看到的方式（不管这些线程在寄存器中、在处理器特定的缓存中，还是通过指令重排或者其他编译器优化），不受缓存变量值的约束，但是如果开发人员使用了同步，如下面的代码所示，那么运行库将确保某一线程对变量所做的更新先于对现有 synchronized 块所进行的更新，当进入由同一监控器（lock）保护的另一个 synchronized 块时，将立刻可以看到这些对变量所做的更新。类似的规则也存在于 volatile 变量上。有兴趣可以参考：<a href="https://blog.csdn.net/fw0124/article/details/6672522" target="_blank" rel="external">Java中的ReentrantLock和synchronized两种锁定机制的对比</a></p>
</blockquote>
<p>在Java 5以前，synchronized是仅有的同步手段，在代码中，synchronized可以用来修饰方法，也可以使用在特定的代码块上，本质上synchronized方法等同于把方法全部语句用synchronized块包起来。</p>
<p>ReentranLock，通常翻译为再入锁，是Java 5提供的锁实现，他的语义和synchronized基本相同。再入锁通过代码直接调用Lock()方法获取，代码书写也更加灵活。与此同时，ReentrantLock提供了很多实用方法，能够实现很多synchronized无法做到的细节控制，比如可以控制fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须明确调用unlock()方法释放，不然就会一直持有该锁。</p>
<p>synchronized和ReentrantLock的性能不能一概而论，早期版本synchronized在很多场景下性能相差较大，在后续版本进行了较多的改进，在低竞争场景中表现可能优于ReentrantLock。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/fw0124/article/details/6672522" target="_blank" rel="external">Java中的ReentrantLock和synchronized两种锁定机制的对比</a></li>
<li>极客时间APP核心技术第十五讲|  synchronized和ReentantLock有什么区别？</li>
</ul>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"> </p>
<p>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发类库提供的线程池有哪几种？分别有什么特点？" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/21/Java并发类库提供的线程池有哪几种？分别有什么特点？/" class="article-date">
      <time datetime="2018-03-21T15:53:18.000Z" itemprop="datePublished">2018-03-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/21/Java并发类库提供的线程池有哪几种？分别有什么特点？/">Java并发类库提供的线程池有哪几种？分别有什么特点？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>Java并发库提供的线程池有哪几种？分别有什么特点？</p>
<h2 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h2><h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h4><p><img src="http://upload-images.jianshu.io/upload_images/1870398-3dd8961e3e118159.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="ThreadPoolExecutor-线程池类"><a href="#ThreadPoolExecutor-线程池类" class="headerlink" title="ThreadPoolExecutor 线程池类"></a>ThreadPoolExecutor 线程池类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">             Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><p>corePoolSize：核心线程数。</p>
</li>
<li><p>maximumPoolSize：最大线程数。</p>
</li>
<li><p>keepAliveTime：线程存活时间。当线程数大于core数，那么超过该时间的线程将会被终结。</p>
</li>
<li><p>unit：keepAliveTime的单位。java.util.concurrent.TimeUnit类存在静态静态属性： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS</p>
</li>
<li><p>workQueue：Runnable的阻塞队列。若线程池已经被占满，则该队列用于存放无法再放入线程池中的Runnable。</p>
</li>
</ul>
<h2 id="回答问题："><a href="#回答问题：" class="headerlink" title="回答问题："></a>回答问题：</h2><p>通常开发者都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的ExecutorService类型或者不同的初始参数。<br>Executors目前提供了5种不同的线程池创建配置：</p>
<ul>
<li>newCachedThreadPool()，它是一种<strong>用来处理大量短时间工作任务的线程池</strong>；它会试图缓存线程并且重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60s，则被终止并移除缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。</li>
</ul>
<p><strong>构造方法（看英文注释是最好的理解哈）：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Creates a thread pool that creates new threads as needed, but</div><div class="line">     * will reuse previously constructed threads when they are</div><div class="line">     * available.  These pools will typically improve the performance</div><div class="line">     * of programs that execute many short-lived asynchronous tasks.</div><div class="line">     * Calls to &#123;@code execute&#125; will reuse previously constructed</div><div class="line">     * threads if available. If no existing thread is available, a new</div><div class="line">     * thread will be created and added to the pool. Threads that have</div><div class="line">     * not been used for sixty seconds are terminated and removed from</div><div class="line">     * the cache. Thus, a pool that remains idle for long enough will</div><div class="line">     * not consume any resources. Note that pools with similar</div><div class="line">     * properties but different details (for example, timeout parameters)</div><div class="line">     * may be created using &#123;@link ThreadPoolExecutor&#125; constructors.</div><div class="line">     *</div><div class="line">     * @return the newly created thread pool</div><div class="line">     */</div><div class="line">    public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                      60L, TimeUnit.SECONDS,</div><div class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>newFixedThreadPool(int nThreadPool)，重要指定数目（nThreads)的线程，其背后使用的无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</li>
</ul>
<p><strong>构造方法（看英文注释是最好的理解哈）：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Creates a thread pool that reuses a fixed number of threads</div><div class="line">    * operating off a shared unbounded queue.  At any point, at most</div><div class="line">    * &#123;@code nThreads&#125; threads will be active processing tasks.</div><div class="line">    * If additional tasks are submitted when all threads are active,</div><div class="line">    * they will wait in the queue until a thread is available.</div><div class="line">    * If any thread terminates due to a failure during execution</div><div class="line">    * prior to shutdown, a new one will take its place if needed to</div><div class="line">    * execute subsequent tasks.  The threads in the pool will exist</div><div class="line">    * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;.</div><div class="line">    *</div><div class="line">    * @param nThreads the number of threads in the pool</div><div class="line">    * @return the newly created thread pool</div><div class="line">    * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125;</div><div class="line">    */</div><div class="line">   public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">       return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                     0L, TimeUnit.MILLISECONDS,</div><div class="line">                                     new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>newSingleThreadExcutor()，它的特点在于工作线程数目被限制为1，操作了一个无界的工作队列，所以它保证了所有任务都是被顺序执行的。最多会有一个任务处于活动状态，<strong>并且不允许使用者改动线程池实例，因此可以避免其改变线程数目</strong>。</li>
</ul>
<p><strong>构造方法（看英文注释是最好的理解哈）：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Creates an Executor that uses a single worker thread operating</div><div class="line">     * off an unbounded queue. (Note however that if this single</div><div class="line">     * thread terminates due to a failure during execution prior to</div><div class="line">     * shutdown, a new one will take its place if needed to execute</div><div class="line">     * subsequent tasks.)  Tasks are guaranteed to execute</div><div class="line">     * sequentially, and no more than one task will be active at any</div><div class="line">     * given time. Unlike the otherwise equivalent</div><div class="line">     * &#123;@code newFixedThreadPool(1)&#125; the returned executor is</div><div class="line">     * guaranteed not to be reconfigurable to use additional threads.</div><div class="line">     *</div><div class="line">     * @return the newly created single-threaded Executor</div><div class="line">     */</div><div class="line">    public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">        return new FinalizableDelegatedExecutorService</div><div class="line">            (new ThreadPoolExecutor(1, 1,</div><div class="line">                                    0L, TimeUnit.MILLISECONDS,</div><div class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>newSingleThreadScheduledExcutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，<strong>可以进行定时或周期性的工作调度</strong>，区别在于单一工作线程还是多个工作线程。</li>
</ul>
<p>构造方法（注释是最好的解释哈）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Creates a thread pool that can schedule commands to run after a</div><div class="line">     * given delay, or to execute periodically.</div><div class="line">     * @param corePoolSize the number of threads to keep in the pool,</div><div class="line">     * even if they are idle</div><div class="line">     * @return a newly created scheduled thread pool</div><div class="line">     * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125;</div><div class="line">     */</div><div class="line">    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</div><div class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>- newWorkStealingPool(int parallelism)这是一个经常被人忽略的线程池，它是Java 8 才加入这个创建方法，其内部会创建ForkJoinPool，利用Work-Stealing算法，并行的处理任务，不保证处理顺序。</strong><br>构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Creates a thread pool that maintains enough threads to support</div><div class="line">     * the given parallelism level, and may use multiple queues to</div><div class="line">     * reduce contention. The parallelism level corresponds to the</div><div class="line">     * maximum number of threads actively engaged in, or available to</div><div class="line">     * engage in, task processing. The actual number of threads may</div><div class="line">     * grow and shrink dynamically. A work-stealing pool makes no</div><div class="line">     * guarantees about the order in which submitted tasks are</div><div class="line">     * executed.</div><div class="line">     *</div><div class="line">     * @param parallelism the targeted parallelism level</div><div class="line">     * @return the newly created thread pool</div><div class="line">     * @throws IllegalArgumentException if &#123;@code parallelism &lt;= 0&#125;</div><div class="line">     * @since 1.8</div><div class="line">     */</div><div class="line">    public static ExecutorService newWorkStealingPool(int parallelism) &#123;</div><div class="line">        return new ForkJoinPool</div><div class="line">            (parallelism,</div><div class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</div><div class="line">             null, true);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/shijiaqi1066/p/3412300.html" target="_blank" rel="external">https://www.cnblogs.com/shijiaqi1066/p/3412300.html</a></li>
<li><a href="http://www.infoq.com/cn/articles/executor-framework-thread-pool-task-execution-part-01" target="_blank" rel="external">戏（细）说Executor框架线程池任务执行全过程（上）</a></li>
<li>极客时间APP核心技术第21讲|  Java并发类库提供的线程池有哪几种？分别有什么特点？</li>
</ul>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"> </p>
<p>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java并发/">Java并发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进阶–int和Integer的理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/21/Android进阶–int和Integer的理解/" class="article-date">
      <time datetime="2018-03-21T14:04:58.000Z" itemprop="datePublished">2018-03-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/21/Android进阶–int和Integer的理解/">Android进阶–int和Integer的理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>今天早高峰在地铁上突然有一个疑惑：String 是immutable是为了保证线程安全，Integer也是Immutable，为什么并发的时候建议使用AtomicInteger呢？</p>
</blockquote>
<p>晚上回来查阅相关资料得出总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">String a=&quot;test&quot;;</div><div class="line">String b=&quot;test&quot;;</div><div class="line">System.out.println(a==b);</div><div class="line">System.out.println(System.idntityHashCode(a));</div><div class="line">System.out.println(System.identityHashCode(b));</div><div class="line"></div><div class="line">输出：true</div><div class="line">851664923</div><div class="line">851664923</div><div class="line">    </div><div class="line">//为什么有觉得可变呢？    </div><div class="line">String a=&quot;test&quot;;</div><div class="line">a=&quot;test1&quot;</div></pre></td></tr></table></figure>
<p>a就变成了test1，其实在这里是新建了一个”test1”字符串对象(如果常量池没有这个值的话就是新建)。<strong>然后将变量引用指向它</strong>。注意：<strong>这里并没有修改”test”这个变量的内部状态，”test”这个字符串对象是线程安全的</strong>。<br>除非你用final修饰，否则所有的变量指向都是可变的。<br>这种情况下要保证线程安全性：</p>
<ul>
<li>可以考虑使用volatile确保可见性。</li>
<li>可以使用final修饰</li>
<li>你可以使用AtomicReference之类的原子对象，对于Integer等也有AtomicInteger之类的</li>
<li>对相应代码区域加锁</li>
</ul>
<p>有兴趣可以查看这两篇文章：<br><a href="https://segmentfault.com/q/1010000007763710" target="_blank" rel="external">String是线程安全的吗？那String岂不是不能进行同步？</a><br><a href="https://www.cnblogs.com/skywang12345/p/3514623.html" target="_blank" rel="external">Java多线程系列–“JUC原子类”04之 AtomicReference原子类</a></p>
<p>综上：String Immutable为了线程安全知识相对的（字符串常量值不可变），但是引用可变，所以为了并发的时候线程安全，可以使用上面所说的几种方案。（如果有更好的认识深度，欢迎讨论）有兴趣可以查看我之前写的一篇文章关于介绍：<a href="https://www.jianshu.com/p/d5da2e9f00e8" target="_blank" rel="external">String为什么是final修饰的</a></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h4><ul>
<li>int和Integer有什么区别？谈谈Integer的值缓存范围？</li>
</ul>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li>Integer缓存或者String 常量池缓存用到的设计模式-享元模式。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-7683ebada719a654?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>相关代码（好记性不如烂笔头，代码是最好的理解）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package yonghui.cn.firstthread.flyweight;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 作者：huangchen on 2018/7/26 20:57</div><div class="line"> * 邮箱：huangchen@yonghui.cn</div><div class="line"> */</div><div class="line">public interface IBike &#123;</div><div class="line">    void biliing(int  time);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package yonghui.cn.firstthread.flyweight;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 作者：huangchen on 2018/7/26 20:58</div><div class="line"> * 邮箱：huangchen@yonghui.cn</div><div class="line"> */</div><div class="line">public class ShareBike implements IBike &#123;</div><div class="line">    private int price;//单价</div><div class="line">    private int total;//总价</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void biliing(int time) &#123;</div><div class="line">        System.out.println(&quot;total price is&quot; + price * time);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package yonghui.cn.firstthread.flyweight;</div><div class="line"></div><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 作者：huangchen on 2018/7/26 20:11</div><div class="line"> * 邮箱：huangchen@yonghui.cn</div><div class="line"> */</div><div class="line">public class FlyWeightFactory &#123;</div><div class="line">    private HashMap&lt;String, IBike&gt; map = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    public IBike getIBike(String name) &#123;</div><div class="line">        IBike iBike;</div><div class="line">        if (map.containsKey(name)) &#123;</div><div class="line">            System.out.println(&quot;押金已经交过了&quot; + name);</div><div class="line">            iBike = map.get(name);</div><div class="line">            return iBike;</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;押金没有交，开始交押金299元&quot;);</div><div class="line">            iBike = new ShareBike();</div><div class="line">            map.put(name, iBike);</div><div class="line">            return iBike;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package yonghui.cn.firstthread.flyweight;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 作者：huangchen on 2018/7/26 20:16</div><div class="line"> * 邮箱：huangchen@yonghui.cn</div><div class="line"> */</div><div class="line">public class Client &#123;</div><div class="line">    public void test()&#123;</div><div class="line">        FlyWeightFactory flyWeightFactory = new FlyWeightFactory();</div><div class="line">        IBike ofo = flyWeightFactory.getIBike(&quot;ofo&quot;);</div><div class="line">        ofo.biliing(2);</div><div class="line">        IBike mobike = flyWeightFactory.getIBike(&quot;mobike&quot;);</div><div class="line">        mobike.biliing(1);</div><div class="line">        IBike ofo1 = flyWeightFactory.getIBike(&quot;ofo&quot;);</div><div class="line">        ofo1.biliing(3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于享元模式有兴趣可以参考：<a href="https://www.jianshu.com/p/1dc997737dd3" target="_blank" rel="external">Android的设计模式-享元模式</a>。</p>
<ol>
<li>自动装箱、自动拆箱发生在编译阶段。静态工厂方法valueof()使用了缓存机制，自动装箱的时候，缓存机制起作用。实际开发中，避免无意的装箱、拆箱行为（不管是内存使用还是运行速度、10w个Java对象比10w整数的开销要大得多，光是对象头空间占用已经是数量级的差距了）。</li>
<li><p>对象的内存结构：对象由对象头、对象实例、对齐填充三部分组成。具体有兴趣可以参考：<a href="https://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="external">Java对象内存布局</a></p>
<h4 id="回答问题："><a href="#回答问题：" class="headerlink" title="回答问题："></a>回答问题：</h4><p>int是我们常说的整形，是八大基本数据类型之一，占4个字节，取值范围2的31次方减去1，Java需要号称一切都是对象，但是基本数据类型是个例外。</p>
<p>Integer是int对应的包装类，他有一个int类型存字段(private final修饰，Immutable)，并且提供了基本操作，比如数字运算、int和字符串之间的转换。在Java5中，引入了自动装箱、拆箱功能。Java根据上下文，自动进行转换，极大简化了相关编程。</p>
<p>关于Integer的值缓存，这涉及Java5的内一个改进。大部分数据操作都集中在有限的、较小的数值范围，因而，在Java 5 中新增了静态工厂方法valueof,在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照Javadoc，这个值默认缓存-128-127之间。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//Integer部分源码</div><div class="line">//Immutable private final</div><div class="line">/**</div><div class="line">     * The value of the &#123;@code Integer&#125;.</div><div class="line">     *</div><div class="line">     * @serial</div><div class="line">     */</div><div class="line">    private final int value;</div><div class="line"> /**</div><div class="line">     * Returns an &#123;@code Integer&#125; instance representing the specified</div><div class="line">     * &#123;@code int&#125; value.  If a new &#123;@code Integer&#125; instance is not</div><div class="line">     * required, this method should generally be used in preference to</div><div class="line">     * the constructor &#123;@link #Integer(int)&#125;, as this method is likely</div><div class="line">     * to yield significantly better space and time performance by</div><div class="line">     * caching frequently requested values.</div><div class="line">     *</div><div class="line">     * This method will always cache values in the range -128 to 127,</div><div class="line">     * inclusive, and may cache other values outside of this range.</div><div class="line">     *</div><div class="line">     * @param  i an &#123;@code int&#125; value.</div><div class="line">     * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;.</div><div class="line">     * @since  1.5</div><div class="line">     */</div><div class="line">    public static Integer valueOf(int i) &#123;</div><div class="line">        assert IntegerCache.high &gt;= 127;</div><div class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">        return new Integer(i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://segmentfault.com/q/1010000007763710" target="_blank" rel="external">String是线程安全的吗？那String岂不是不能进行同步？</a></li>
<li><a href="https://www.cnblogs.com/skywang12345/p/3514623.html" target="_blank" rel="external">Java多线程系列–“JUC原子类”04之 AtomicReference原子类</a></li>
<li><a href="https://www.jianshu.com/p/d5da2e9f00e8" target="_blank" rel="external">String为什么是final修饰的</a></li>
<li><a href="https://www.jianshu.com/p/1dc997737dd3" target="_blank" rel="external">Android的设计模式-享元模式</a>。</li>
<li><a href="https://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="external">Java对象内存布局</a></li>
<li>Integer部分源码</li>
<li>极客时间APP核心技术第七讲|int和Integer有什么区别？</li>
<li>自己写的Demo中部分代码</li>
</ul>
<blockquote>
<p>声明：此为原创，转载请联系作者</p>
</blockquote>
<hr>
<p>作者：微信公众号添加公众号-<strong>遛狗的程序员</strong>  ，或者可以扫描以下二维码关注相关技术文章。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-a702fdb2432ef815.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qrcode_for_gh_1ba0785324d6_430.jpg"><br>当然喜爱技术，乐于分享的你也可以可以添加作者微信号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1870398-8a29e6df15db4e07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WXCD.jpeg"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java进阶/">Java进阶</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 黄尘
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>